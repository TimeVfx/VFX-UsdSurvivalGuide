# Materials [材质]
Materials in USD are exposed via the [UsdShade](https://openusd.org/dev/api/usd_shade_page_front.html) module.

[ USD 中的材质是通过 UsdShade 模块来展示的]

Shader networks are encoded via the [UsdShade.ConnectableAPI](https://openusd.org/dev/api/class_usd_shade_connectable_a_p_i.html). So we have full access to the node graph as it is fully represented as USD prims. This allows for flexible editing, as it is as simple as editing attributes and connections on your individual material node prims.

[ Shader networks 是通过 [UsdShade.ConnectableAPI](https://openusd.org/dev/api/class_usd_shade_connectable_a_p_i.html) 进行编码的. 因此我们可以访问 node graph，因为它以 USD prims 的形式表示. 这允许我们进行灵活的编辑，因为编辑单个材质节点 prims 上的属性和连接都很简单]

USD has support for encoding [MaterialX](https://materialx.org/) node graphs, which allows for render engine agnostic shader creation.

[ USD 支持对 [MaterialX](https://materialx.org/) 节点图进行编码，这使得创建与渲染引擎无关的着色器成为可能]

# Table of Contents [目录]
1. [Materials In-A-Nutshell](#summary)
1. [What should I use it for?](#usage)
1. [Resources](#resources)
1. [Overview](#overview)
    1. [Material Binding](#materialBinding)
    1. [Node graph encoding via attribute to attribute connections](#materialNodeGraph)

## TL;DR - Metadata In-A-Nutshell [概述]<a name="summary"></a>
- USD can encode material node graphs as prims. It supports writing [MaterialX](https://materialx.org/) node graphs, which are renderer agnostic material descriptions.

    [ USD 可以将材质节点图编码为 prims. 它支持编写 [MaterialX](https://materialx.org/) 节点图，这是与渲染器无关的材质描述]
- We can bind materials either directly or via [collections](./collection.md).

    [ 我们可以直接或通过 [集合](./collection.md) 关联绑定材质]

## What should I use it for? <a name="usage"></a>

[ 我应该用它做什么？]

~~~admonish tip
Materials themselves are usually generated by the DCC you are working in, so we usually don't have to create them ourselves. What we do use the `UsdShade` module for is editing material bindings and overriding individual nodes and their connections in a material node graph.

[ 材质本身通常由你正在使用的 DCC 生成所以我们通常不需要自己创建它们. 我们使用 UsdShade 模块的目的是编辑材质绑定，以及覆盖材质节点图中的单个节点及其连接 ]
~~~

## Resources [资源]<a name="resources"></a>
- [UsdShade](https://openusd.org/dev/api/usd_shade_page_front.html)
- [UsdShade.Material](https://openusd.org/dev/api/class_usd_shade_material.html)
- [UsdShade.MaterialBindingAPI](https://openusd.org/dev/api/class_usd_shade_material_binding_a_p_i.html)
- [UsdShade.ConnectableAPI](https://openusd.org/dev/api/class_usd_shade_connectable_a_p_i.html)

## Overview [概述]<a name="overview"></a>
~~~admonish question title="Still under construction!"
This section still needs some more love, we'll likely expand it more in the near future.

[ 这部分内容还需要进一步完善，我们可能在不久的将来会对其进行更多的扩展]
~~~

### Material binding [材质绑定]<a name="materialBinding">
One of the most common use cases of relationships is encoding the material binding. Here we simply link from any imageable (renderable) prim to a `UsdShade.Material` (`Material`) prim.

[ 关联关系最常见的用例之一是对材质的绑定. 在这里我们简单地从任何 imageable (renderable) prim 链接到 UsdShade.Material ( Material ) prim]

~~~admonish important
Material bindings are a special kind of relationship. Here are a few important things to know:

[ 材质绑定是一种特殊的关系. 以下是几个重要的知识点]
- When looking up material bindings, USD also looks at parent prims if it can't find a written binding on the prim directly. This means you can create the binding on any parent prim and just as with primvars, it will be inherited downwards to its children.

    [ 在查找材质绑定时，如果 USD 无法在 prim 上直接找到已写入的绑定，它还会查看父级 prims 这意味着你可以在任何父级 prim 上创建绑定，就像 primvars 一样它会被继承并应用到其子级]
- The "binding strength" can be adjusted, so that a child prim assignment can also be override from a binding higher up the hierarchy.

    [ “绑定强度”可以调整，这样子级 prim 的分配也可以从层级结构中更高级别的绑定中覆盖]
- Material bindings can also be written per purpose, if not then they bind to all purposes. (Technically it is not called purpose, the token names are `UsdShade.MaterialBindingAPI.GetMaterialPurposes() -> ['', 'preview', 'full']`). The 'preview' is usually bound to the 'UsdGeom.Tokens.proxy' purpose, the 'full' to the 'UsdGeom.Tokens.render' purpose.

    [ 材质绑定也可以按 purpose 来编写，如果没有指定 purpose 则它们会绑定到所有 purpose（技术上并不称之为 purpose，而是使用标记名称 UsdShade.MaterialBindingAPI.GetMaterialPurposes() -> ['', 'preview', 'full']）通常，“preview” 绑定到 “UsdGeom.Tokens.proxy” purpose，“full” 绑定到 “UsdGeom.Tokens.render” purpose]
- The material binding can be written in two ways:

    [ 材质绑定可以以两种方式编写]
    - Direct Binding: A relationship that points directly to a material prim

        [ 直接绑定：直接指向材质 prim 的关系]
    - Collection Based Binding: A relationship that points to another collection, that then stores the actual binding paths) and to a material prim to bind.

        [ 基于集合的绑定：指向另一个集合的关系，该集合存储实际的绑定路径，以及要绑定的材质 prim]
~~~

Here is an example of a direct binding:

[ 以下是直接绑定的案例]

```python
over "asset"
{
    over "GEO"(
        prepend apiSchemas = ["MaterialBindingAPI"]
    )
    {
        rel material:binding = </materials/metal>
        over "plastic_mesh" (
            prepend apiSchemas = ["MaterialBindingAPI"]
        )
        {
            rel material:binding = </asset/materials/plastic>
        }
    }
}
```

And here is an example of a collection based binding. As you can see it is very easy to exclude a certain prim from a single control point, whereas with the direct binding we have to author it on the prim itself.

[ 以下是一个基于集合的绑定的示例. 如您所见，从一个控制点上排除某个 prim 非常容易，而使用直接绑定时，我们必须在 prim 上进行设置]

```python
def "asset" (
    prepend apiSchemas = ["MaterialBindingAPI", "CollectionAPI:material_metal"]
)
{
    rel material:binding:collection:material_metal = [
        </shaderball.collection:material_metal>,
        </materials/metal>,
    ]

    uniform token collection:material_metal:expansionRule = "expandPrims"
    rel collection:material_metal:includes = </asset>
    rel collection:material_metal:excludes = </asset/GEO/plastic_mesh>
}
```

For creating bindings in the high level API, we use the `UsdShade.MaterialBindingAPI` schema.
Here is the link to the official [API docs](https://openusd.org/dev/api/class_usd_shade_material_binding_a_p_i.html).

[ 在高级 API 中创建绑定，我们使用 UsdShade.MaterialBindingAPI 这是官方 [API](https://openusd.org/dev/api/class_usd_shade_material_binding_a_p_i.html) 文档的链接]

For more info about the load order (how collection based bindings win over direct bindings), you can read the "Bound Material Resolution" section on the API docs page.

[ 有关加载顺序的更多信息（基于集合的绑定如何胜过直接绑定），您可以阅读 API 文档页面上的“绑定材质解析”部分]

~~~admonish tip title=""
```python
{{#include ../../../../code/core/elements.py:relationshipMaterialBinding}}
```
~~~


### Node graph encoding via attribute to attribute connections <a name="materialNodeGraph"></a>
Attributes can also encode relationship-like paths to other attributes. These connections are encoded directly on the attribute. It is up to Usd/Hydra to evaluate these "attribute graphs", if you simply connect two attributes, it will not forward attribute value A to connected attribute B (USD does not have a concept for a mechanism like that (yet)).

[ 属性还可以链接到其他属性,类似属性路径. 通过连接直接编码在属性上. 由 Usd/Hydra 来评估这些 “attribute graphs”，如果你只是简单地将两个属性连接起来，它并不会将属性值 A 转发到连接的属性 B（USD 还没有这样的机制概念（至少目前还没有））]

Here is an example of how a material network is encoded.

[ 这是如何对材质网络进行编码的示例]

~~~admonish important title=""
```python
def Scope "materials"
{
    def Material "karmamtlxsubnet" (
    )
    {
        token outputs:mtlx:surface.connect = </materials/karmamtlxsubnet/mtlxsurface.outputs:out>

        def Shader "mtlxsurface" ()
        {
            uniform token info:id = "ND_surface"
            string inputs:edf.connect = </materials/karmamtlxsubnet/mtlxuniform_edf.outputs:out>
            token outputs:out
        }

        def Shader "mtlxuniform_edf"
        {
            uniform token info:id = "ND_uniform_edf"
            color3f inputs:color.connect = </materials/karmamtlxsubnet/mtlx_constant.outputs:out>
            token outputs:out
        }

        def Shader "mtlx_constant"
        {
            uniform token info:id = "ND_constant_float"
            float outputs:out
        }
    }
}
```
~~~

In our [property](./property.md#attribute-to-attribute-connections-node-graph-encoding) section we cover the basics how to connect different attributes. For material node graphs USD ships with the [UsdShade.ConnectableAPI](https://openusd.org/dev/api/class_usd_shade_connectable_a_p_i.html). It should be used/preferred instead of using the `Usd.Attribute.AddConnection` method, as it does extra validation as well as offer convenience functions for iterating over connections.

[ 在我们的 [property](./property.md#attribute-to-attribute-connections-node-graph-encoding) 部分，我们介绍了如何连接不同属性的基础知识. 对于材质节点图，USD提供了 [UsdShade.ConnectableAPI](https://openusd.org/dev/api/class_usd_shade_connectable_a_p_i.html) 应该使用/优先使用它，而不是使用 Usd.Attribute.AddConnection 方法，因为它进行了额外的验证，并为遍历连接提供了便利的函数]
